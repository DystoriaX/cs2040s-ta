{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CS2040S T40 Resources","text":""},{"location":"#ay-20222023-sem-2","title":"AY 2022/2023 Sem 2","text":"<p>This website is intented for CS2040S student's supplementary material. Write-ups for every PS and tutorial slides can be retrieved here.</p>"},{"location":"write-up/ps1/","title":"PS1","text":""},{"location":"write-up/ps1/#styling-issues","title":"Styling Issues","text":"<p>I noticed many of you are not accustomed to the standard styling of Java. You are going to learn that in CS2030S, but I would like to highlight some important guides that I found: member variable and method names should use <code>camelCase</code>. If your constructor has the same variable names with the member variables', you can refer to member variable with <code>this.memberVariable</code>.</p> <pre><code>class Cat {\nprivate String name;\nprivate int age;\npublic Cat(String name, int age) {\nthis.name = name;\nthis.age = age;\n}\n}\n</code></pre> <p>Don't forget that member variables should be <code>private</code>, as we do not want external user to modify a property of our object. Methods should usually be <code>public</code> unless you do not want external user to call the method (typically helper functions).</p>"},{"location":"write-up/ps1/#trivia","title":"Trivia","text":"<p>If it is possible to work only with integers, we prefer to do so if precision is of concern. Note that working with floating-point number implies that we sacrifices our precision.</p>"},{"location":"write-up/ps1/#reflection","title":"Reflection","text":"<p>Most of you initialized the seed (which is an array) using assignment (i.e. <code>this.seed = seed</code>). Do you think this is a good idea? If not, why?</p> Reveal answer <p>Array type in Java is a reference type. It means that if we do an assignment from a variable to another, they share the same reference to the same entity. Consequently, if one variable change its value, the effect will apparent to other values who share the same reference. Try run this code on <code>jshell</code></p> <pre><code>int[] a = {1, 2, 3};\nint[] b = a;\na[0] = 10;\na; // returns {10, 2, 3}\nb; // returns {10, 2, 3}, too! :(\n</code></pre> <p>After modification in line 3, you would expect that the value of <code>b</code> should not change. In fact, at line 5, the value of <code>b</code> changes too!</p>"},{"location":"write-up/ps2/","title":"PS2","text":""},{"location":"write-up/ps2/#styling-issues","title":"Styling Issues","text":"<p>Most of you do not have this issue, but please at least try to write a readable code. At the very least:</p> <ul> <li>Indent properly (very important!)<ul> <li>There could be differences in indentation of you mix up <code>&lt;Tab&gt;</code> and <code>&lt;spaces&gt;</code>.   Since most of you use IntelliJ for development, you can try to follow   this guide   to change your indentation settings. I would recommend to use spaces of 4. Please   check that your submitted program is also indented properly.</li> </ul> </li> <li> <p>Proper braces (very important!)</p> <ul> <li>Even though the if-block has only one line statement, please use braces to   make it clear the scope of your if block.</li> </ul> <pre><code>if (n &lt; 1) // Use braces...\nSystem.out.println(\"Bad\");\nif (n &lt; 2) { // Like this\nSystem.out.println(\"Good\");\n}\n</code></pre> </li> <li> <p>Meaningful (at least representative) variable names</p> </li> <li>No magic numbers (give the number names!)<ul> <li>See Don't Write Comments</li> </ul> </li> <li><code>camelCase</code> for variable names and functions</li> <li><code>CAPITAL_SNAKE_CASE</code> for constants</li> <li><code>PascalCase</code> for class/interface names</li> </ul> <p>If I find your code hard to read due to bad presentation, marks will be deducted.</p>"},{"location":"write-up/ps2/#common-mistakes","title":"Common mistakes","text":"<p>Some of you forget to put the big-O when doing complexity analysis. Note that this is important. Stating that an algorithm runs in \\(f(n)\\) means that it takes exactly \\(f(n)\\) steps, when in fact some constant factors might be involved. Therefore, it is more accurate to write down our complexity using asymptotic notation. You can use any of big-O, big-Omega, or big-Theta, depends on what you are trying to convey.</p> <p>\"The algorithm runs in \\(\\mathcal{O}(f(n))\\)\" means that it is upperbounded by some constant factor of \\(f(n)\\) for large values \\(n\\), i.e. cannot be worse than \\(c \\cdot f(n), \\forall n &gt; n_0\\) for some positive constants \\(c, n_0\\)</p>"},{"location":"write-up/ps2/#improvement-suggestions","title":"Improvement Suggestions","text":""},{"location":"write-up/ps2/#if-else-return","title":"If-else return","text":"<p>The returning-boolean-if-else functions can be simplified. Compare the following.</p> <pre><code>boolean isLarger(int a, int b) {\nif (a &gt; b) {\nreturn true;\n} else {\nreturn false;\n}\n}\nboolean betterIsLarger(int a, int b) {\nreturn a &gt; b;\n}\n</code></pre>"},{"location":"write-up/ps2/#avoid-nested-code","title":"Avoid Nested Code","text":"<p>Nested codes are not recommended in practice as it hurts readability. Two to three nests are acceptable, but more than that is... bad. You are going to learn this more later in your software engineering module. Most of the time, it is possible to refactor (i.e. restructure) your code. For instance, handle all edge cases that is not part of main logic in if else statement.</p> <p>Further reference (recommended): Why you shouldn't nest your code</p>"},{"location":"write-up/ps2/#binary-search-implementation","title":"Binary Search Implementation","text":"<p>Some of your binary search implementation could have been improved. The following is my usual implementation of binary search for lowerbound (i.e. finding the first index such that <code>arr[index] &gt;= x</code>, where <code>x</code> is the value of interest and <code>arr[]</code> is a non-decreasingly sorted array).</p> <pre><code>int lowerBound(int[] arr, int x) {\nint l = 0;\nint r = arr.length - 1;\nwhile (l &lt; r) {\nint mid = l + (r - l) / 2;\nif (a[mid] &gt;= x) {\nr = mid;\n} else {\nl = mid + 1;\n}\n}\n// at this point, l = r\nreturn l;\n}\n</code></pre> <p>Some important notes:</p> <ul> <li>At line 6, it is preferred to do that way instead of <code>mid = (l + r) / 2</code>. There   is a possibility of overflow when we calculating <code>l + r</code>. Though chances are   low, but when it occurs, it will be very frustrating to debug.</li> <li>At the end of loop, we can infer that <code>l</code> = <code>r</code> for two reasons:<ul> <li>While loop stops when <code>l</code> &gt;= <code>r</code></li> <li>It is not possible for <code>l</code> &gt; <code>r</code> (you can try to deduce this from revery   possible branch statements executed)</li> </ul> </li> <li>Let's consider what <code>l</code> points during the loop execution. If we try to visualize what   is happening during the loop, if <code>arr[l] &lt; x</code>, it will always move to right until   <code>arr[l] &gt;= x</code>, and the final value of <code>l</code> is the answer, i.e. the first index whose value   is &gt;= <code>x</code>. This is true as we only move <code>l</code> to <code>mid + 1</code> when <code>arr[mid] &lt; x</code>.   This implies that either:<ul> <li><code>arr[mid + 1] &lt; x</code>, which means that the value <code>l</code> will continue to change again</li> <li><code>arr[mid + 1] &gt;= x</code>, this means that <code>mid + 1</code> = <code>l</code> is the first index whose   value is &gt;= <code>x</code>. At this point, <code>l</code> will never change its value again.</li> </ul> </li> <li>From the reasoning above, we can conclude that <code>arr[l] &gt;= x</code> and <code>l</code> is the answer.</li> <li>If you want to handle the case where there is no <code>index</code> such that <code>arr[index] &gt;= x</code>,   initialize <code>r</code> to <code>arr.length</code>. If the function returns <code>arr.length</code>, then there is   no such index. Think why this works.</li> </ul>"},{"location":"write-up/ps2/#questions-to-ponder","title":"Questions to Ponder","text":"<ul> <li>On my binary search implementation, what is my pre-condition, loop invariant,   and post-condition?</li> </ul>"},{"location":"write-up/ps3/","title":"PS3","text":""},{"location":"write-up/ps3/#things-to-note","title":"Things to Note","text":"<ul> <li>Ensure that you do not print anything to <code>stdout</code>, such as using <code>System.out.println</code>. If you use it for debugging purpose, please remember to remove it before submitting.</li> <li>Sometimes you comment out code that is not used. Make sure you also remove that before submission. It helps me to grade your work easier :)</li> <li>Your code has to pass all test cases, public and private! If it doesn't, then most likely your solution is incorrect, or there are missing files.</li> <li>Start early, if possible :\")</li> </ul>"},{"location":"write-up/ps3/#common-mistakes","title":"Common Mistakes","text":"<ul> <li>You cannot compare the performance of two algorithms/sorters just by looking at the cost! A \\(\\mathcal{O}(n \\lg n)\\) algorithm does not always perform worse than \\(\\mathcal{O}(n)\\) algorithm for all input sizes \\(n\\). It also depends with the hidden constant involved. You can look at T3 Q5.</li> <li>To determine whether an algorithn runs in \\(\\mathcal{O}(n^2)\\), you need analyse the growth of the cost, i.e. testing for input size \\(k\\), \\(2k\\), \\(4k\\), \\(8k\\), and so on. Compare how much the cost grows. In this case, you should expect the cost growth is \\(2^2=4\\) times more than the previous one.</li> <li>Some of you argue that the best running time and the worst running time by comparing the significant difference of the cost. This is kinda valid, but I would suggest that use the analysis method as written in point 2.</li> <li>The term of worst case and best case are unique for each algorithm. Hence, you cannot assume that reversed sorted array is the worst case for all sorting algorithms! For instance, it might not be the worst case for QuickSort, as the worst case for QuickSort is when the pivot choice is horrible (uneven partition).</li> </ul>"},{"location":"write-up/ps3/#possible-improvements","title":"Possible Improvements","text":"<ul> <li>Some of you tried to hardcode when check for a sorter's stability. Note that as long as we generate sufficient repeating element, it should be okay. You can generate an array whose element ranging from <code>0</code> to <code>size / 2</code>, where <code>size</code> is the array size.</li> <li>Be aware of edge cases, i.e. checking for array of size <code>0</code> or <code>1</code>.</li> <li>Do extensive testing! Be your own adversary. This is the key for you to get better in anything.</li> </ul>"},{"location":"write-up/ps4/","title":"PS4","text":""},{"location":"write-up/ps4/#things-to-note","title":"Things to Note","text":"<ul> <li>Some of you have redundant checks, which could have/should have been handled by the base case. I have put comments for those who had this issue. When designing recursive function, do ask yourself:<ul> <li>Are there any better base case? Having a better base case will help simplify unnecessary if branch checks when you recurse further down the function.</li> <li>Are there any better way to represent the recurrence relation? (e.g. for <code>rebuild</code>, is it easier to design recursive function for a <code>node</code> or <code>children</code>)</li> </ul> </li> <li>For <code>rebuild</code> function, some of you copy the whole array of <code>TreeNode</code>. Note that this is not recommended! Arguably, it is easier for you to think of rebuilding for an array of <code>TreeNode</code>. However, copying over the content is not a good idea as copying itself takes linear time. This unnecessary cost will make the function slower. You can pass the original array on the function and use pointers instead.</li> <li>For those whom I suggested to use wrapper type <code>Integer</code> instead of the primitive type <code>int</code>, please ignore. I just realized that the wrapper class does not pass the argument by reference.</li> <li>For question 1b (Enumerate Nodes) Some of you attempted the following:<ul> <li>Using <code>int[]</code> to pass by reference. A hacky way to do it :)</li> <li>Using member variable to keep track of index for inorder traversal array. A nicer solution :), but you need to remember to reset the value to <code>0</code> for every function calls on <code>enumerateNodes</code>!</li> </ul> </li> </ul> <p>Note: some programming languages support referring to subarray in \\(\\mathcal{O}(1)\\) time, i.e. it does not copy the whole array. You can implement one on your own, too! See an implementation of <code>ImmutableArray</code> in Java. You might learn this in your CS2030S as well :)</p>"},{"location":"write-up/ps4/#additional-challenges","title":"Additional Challenges","text":"<ul> <li>Problem 1b (Enumerate Nodes) can be solved either iteratively or recursively. Do give it a try :)</li> </ul>"},{"location":"write-up/ps5/","title":"PS5","text":""},{"location":"write-up/ps5/#common-mistakes","title":"Common Mistakes","text":"<ul> <li>For Q2, some of you tried to find highest unbalanced node while inserting the new node. Note that this is fine, but you need to be aware of the mistake when you call the <code>checkBalance</code> function, as there is a chance that you compare the updated-weight node with not-updated-weight children. It's also preferable if you separate the two.</li> <li>For Q4, many of you use the <code>.substring()</code> method. Note that this takes linear time! Though you may not know how it is implemented, but you can infer that it should takes linear, as it returns a <code>String</code> object</li> <li>Please use <code>StringBuilder</code> if you need \\(\\mathcal{O}(1)\\) append operation. And also do not copy the <code>StringBuilder</code> object, as it defeats the purpose of <code>StringBuilder</code>. You can use <code>.setLength()</code>.</li> <li>Notice that <code>.deleteCharAt()</code> method takes \\(\\mathcal{O}(k)\\) time, where \\(k\\) is the number of characters after the character to be deleted. Essentially, if you delete the last character, it's constant time. You can check the implementation of <code>.deleteCharAt()</code> and <code>.setLength()</code>.</li> <li>Lesson: know your library! Don't just use it :( You cannot assume everything is \\(\\mathcal{O}(1)\\). At least make some inference of the cost.</li> </ul>"},{"location":"write-up/ps5/#suggestions","title":"Suggestions","text":"<ul> <li>If your code is deeply nested, please watch this. As much as possible, you do not want your main logic nested inside the <code>if</code> block. In practice, we handle all the edge cases first (which is usually much much shorter), and leave the main logic outside the if braces.</li> <li>If you want the division to work as floating point number, you need to either cast it to type <code>float</code>, or you can make the number into floating point number. For instance, write <code>node.weight * 2.0 / 3.0</code> instead of <code>node.weight * 2 / 3</code>. Both might produce different result.</li> <li>For the point above, if you want to compare, say <code>node.left.weight &lt;= node.weight * 2.0/3.0</code>, it's usually better for us to rearrange the inequality that consists of only integer operations, i.e. <code>node.left.weight * 3 &lt;= node.weight * 2</code></li> <li>In Trie implementation, storing the pointer to children nodes and a flag indicating end-of-word is enough.</li> <li> <p>I see many of the submissions use magic number. As much as possible, try avoid it. For instance, when you try to get the index of a character, try not to write the following:</p> <pre><code>if (48 &lt;= character &amp;&amp; character &lt;= 57) {\nreturn character - 48;\n} else if (65 &lt;= character &amp;&amp; character &lt;= 90) {\nreturn character - 55;\n} ...\n</code></pre> <p>Instead:</p> <pre><code>final int ASCII_0 = 48;\nfinal int ASCII_9 = 57;\nfinal int ASCII_A = 65;\nfinal int ASCII_Z = 90;\nfinal boolean isNumber = ASCII_0 &lt;= character &amp;&amp; character &lt;= ASCII_9;\nfinal boolean isCapital = ASCII_A &lt;= character &amp;&amp; character &lt;= ASCII_Z;\nif (isNumber) {\nreturn character - ASCII_0;\n} else if (isCapital) {\nreturn character - ASCII_A + 10;\n} ...\n</code></pre> <p>Try compare the two. You do not need to decipher what each numbers mean. At least the cognitive load to read the code is less on the second example.</p> </li> </ul>"},{"location":"write-up/ps5/#pseudocode","title":"Pseudocode","text":"<p>Please use the following to compare your code and my pseudocode. See which part you could improve in terms of algorithm and writing style. Note that I do not claim my snippet code is better than yours, but I would like you to think about what's good and what's bad from your solution and my solution.</p> <p>Warning</p> <p>My code has not been tested on Coursemology. If you found any mistake, let me know.</p>"},{"location":"write-up/ps5/#q1","title":"Q1","text":"<pre><code>private int getWeight(TrieNode node) {\nreturn node == null ? 0 : node.weight;\n}\npublic boolean checkBalance(TrieNode node) {\n// Best practice is to check all edge-cases and return straight away\n// We leave the happy-path (i.e. the main logic of the code) in the body\nif (node == null) {\nreturn true;\n}\n// This is the happy-path\n// Notice that I use the condition such that the node is called balanced, instead of calling the negation on unbalanced condition.\nboolean isLeftBalanced = getWeight(node.left) * 3 &lt;= getWeight(node) * 2;\nboolean isRightBalanced = getWeight(node.right) * 3 &lt;= getWeight(node) * 2;\nreturn isLeftBalanced &amp;&amp; isRightBalanced;\n}\n</code></pre>"},{"location":"write-up/ps5/#q3","title":"Q3","text":"<pre><code>  private class TrieNode {\nprivate boolean isEnd;\nprivate TrieNode[] children = new TrieNode[MAX_SIZE];\n// some details are omitted\n...\n}\nvoid insert(String s) {\nTrieNode node = root;\nfor (int i = 0; i &lt; s.length(); i++) {\nchar ch = s.charAt(i);\n// Handle the logic accordingly\n// You could create such method for your TrieNode and let your TrieNode\n// handle the logic, which is a good separation of responsibility.\n// Note that this is a good abstraction barrier between Trie and TrieNode.\nif (!node.isExistChild(ch)) {\nnode.createChild(ch);\n}\nnode = node.getChild(ch);\n}\nnode.markEnd();\n}\nboolean contains(String s) {\nTrieNode node = root;\nfor (int i = 0; i &lt; s.length(); i++) {\nchar ch = s.charAt(i)\nif (!node.isExistChild(ch)) {\nreturn false;\n}\nnode = node.getChild(ch);\n}\nreturn node.isEndWord();\n}\n</code></pre>"},{"location":"write-up/ps5/#q4","title":"Q4","text":"<pre><code>  void prefixSearch(String prefix, ArrayList&lt;String&gt; results, int limit) {\nreturn prefixSearch(prefix, 0, results, limit, this.root, new StringBuilder());\n}\nprivate void prefixSearch(String prefix, int index, ArrayList&lt;String&gt; results,\nTrieNode curNode, StringBuilder curString) {\nif (results.length() &gt;= limit) {\nreturn;\n}\n// Happy path starts here\nif (index &gt;= prefix.length()) {\n// We only add string if we've gone through the whole prefix\nif (curNode.isEndWord()) {\nresults.add(curString.toString());\n}\n// Try concatenating a new one\nfor (int i = 0; i &lt; MAX_SIZE; i++) {\nTrieNode child = curNode.getChildForIndex(i);\nif (child == null) {\ncontinue;\n}\ncurString.append(TrieNode.getCharacterFromIndex(i));\nprefixSearch(prefix, index + 1, results, child, curString);\ncurString.setLength(index);\n}\nreturn;\n}\n// Case where you have to still traverse\nchar curChar = prefix.charAt(index);\nif (curChar == WILDCARD) {\n// Try concatenating a new one\nfor (int i = 0; i &lt; MAX_SIZE; i++) {\nTrieNode child = curNode.getChildForIndex(i);\nif (child == null) {\ncontinue;\n}\ncurString.append(TrieNode.getCharacterFromIndex(i));\nprefixSearch(prefix, index + 1, results, child, curString);\ncurString.setLength(index);\n}\n} else {\nTrieNode child = curNode.getChildForCharacter(curChar);\ncurString.append(curChar);\nprefixSearch(prefix, index + 1, results, child, curString);\ncurString.setLength(index);\n}\n}\n</code></pre>"}]}